## 第4章 关于函数

> Latest: Mon Jan  4 15:54:20 CST 2021

[ABI](https://feilengcui008.github.io/post/abi/)

### 4.2 函数的工作原理

* 返回地址: 函数执行完毕后应该再从哪里开始执行

### 4.3 使用C调用约定的汇编语言函数

* 计算机的栈处于内存地址的最顶端，从内存顶部开始向下增长
* 栈寄存器 `%esp` 总是包含一个指向当前栈顶的指针

### 1. 执行函数前

1. 将所有的参数按逆序压入栈中
2. 发送 `call` 指令

**call指令**

* 将下一条指令的地址即返回地址压入栈中
* 修改指令指针 `%eip` 指向函数起始出

### 2. 函数开始

> 基址指针是一个特殊的寄存器，用于访问函数的参数和局部变量

1. 通过 `pushl %ebp`指令保存当前的基址指针寄存器`%ebp`。
* 用`movl %esp, %ebp` 将栈指针`%esp`复制到基址指针`%ebp`。
* 为其所需的所有局部变量保留栈空间，只需将栈指针向外移动即可实现。

%ebp 将一直是栈指针的函数开始时的位置，所以可以说是对栈帧的常量引用(栈帧包含一个函数中使用的所有栈变量，包括参数、局部变量和返回地址)

```
pushl %ebp
movl %esp, %ebp
subl $8, %ebp
```

> 全局变量和静态变量之间的唯一区别是静态变量只用于一个函数，而全局变量可由许多函数共同使用

**扩展搜索**

* linux 设置堆栈大小
* c语言环境 初始化

### 3. 函数结束

* 将其返回值存储到 `%eax`
* 将栈恢复到调用函数是的状态
* 将控制权交还给调用它的程序, 通过 `ret` 指令实现

```
movl %ebp, %esp
popl %ebp
ret
```

**ret指令**

* 将栈顶的值弹出，并将指令指针寄存器 `%eip` 设置为该弹出值

### 4. 返回调用函数

* 检查 `%eax` 中的返回值
* 弹出其入栈的所有参数(`addl 4xn, %esp`)

### 4.4 函数示例

* `.type power, @function` 这条指令告诉链接器应将 `power` 作为函数处理

### 4.5 递归函数

* 一个递归定义必须包含一个基线条件。`基线条件`就是递归停止的地方
