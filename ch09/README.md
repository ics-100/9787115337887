## 第 9  章 关于中间存储器

### 9.1 计算机如何看待内存

> 计算机中的每一项不在寄存器中的数据都有一个地址。占据多个字节的数据，其地址与数据第一个字节的地址相同
> 
> `指针`是一个寄存器或内存字，其值是一个地址


### 9.2 Linux程序的内存布局

> 实际指令(.text段)被加载到地址`0x08048000` 而.data段紧随其后被加载，再之后是.bbs段
> 
> 在Linux上可以寻址的最后一个字节是存储位置`0xBFFFFFFF`。Linux的栈从这里开始，并向下朝其他段增长。
> 

栈的初始化布局:

> 栈底，处在一个内存字0。接着是ASCII字符表示、以空字符结束的程序名。程序名后是程序的环境变量。接着是程序的命令行参数。
> 
> 程序的数据段从内存底部开始，并向上增长。栈从内存的顶部开始，每次数据入栈都向下移动。这个栈和程序数据段之间的中间部分是你无法访问的。对于你的程序，其最后的可访问内存地址称为`系统中断`


### 9.3 每个内存地址都是虚拟的

> 在计算机上运行的每个程序都认为其被加载到内存地址`0x0804800`, 其栈起始地址为`0xBFFFFF`
> 
> 映射过程需要大量的时间和空间，所以如果每一个可能程序可能的虚拟地址都映射到物理地址，那么连运行一个程序的物理内存可能都不会剩下。所以中断是未映射内存的起始处。

* 内存被拆分成组，这些组称为页。一个页面是4096字节内存。所有的内存映射都是一次映射一个页面。

### 9.4 获取更多的内存

> 如果需要更多的内存，可以告诉Linux你想要新的中断点，而Linux会将你需要的所有内存映射到现有断点与新断点之间，然后将断点移动到你指定的地方。
> 我们是通过 `brk`系统调用告诉Linux移动中断点的。
> 
> * 调用号: 45(%eax)
> * 中断点：%ebx

* 新的中断实际上可能比你要求的大，因为Linux会四舍五入至最接近的页。
* 如果没有足够的物理内存或页面交换能满足你的要求，Linux 将返回 0 到%eax,
* 如果调用 brk 时 %ebx 为0， 该调用仅仅返回最后一个可用内存的地址


内存管理器是一组例程，负责完成为你的程序获取内存

> 分配(allocate) / 回收(deallocate) : 动态内存分配
> 
> C语言`malloc` / `free`
> 
> 内存管理器所使用的内存池通常称为`堆`